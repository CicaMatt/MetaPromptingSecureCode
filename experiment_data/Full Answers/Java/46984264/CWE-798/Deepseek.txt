To address the problem of migrating AES-256 encrypted data from MySQL to SQL Server while ensuring compatibility, we can use a standardized encryption approach that both databases support. One such approach is to use the AES encryption algorithm with a common key and initialization vector (IV). Below is a Java solution that demonstrates how to encrypt and decrypt data in a way that is compatible with both MySQL and SQL Server.

### Java Solution

```java
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
import java.util.Base64;
import java.nio.charset.StandardCharsets;

public class AESCompatibility {

    private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String SECRET_KEY = "YourSecretKey123"; // 16, 24, or 32 bytes
    private static final String INIT_VECTOR = "RandomInitVector"; // 16 bytes

    public static String encrypt(String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(INIT_VECTOR.getBytes(StandardCharsets.UTF_8));
            SecretKeySpec skeySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), "AES");

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static String decrypt(String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(INIT_VECTOR.getBytes(StandardCharsets.UTF_8));
            SecretKeySpec skeySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), "AES");

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] original = cipher.doFinal(Base64.getDecoder().decode(encrypted));
            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) {
        String originalString = "SensitiveData123";

        String encryptedString = encrypt(originalString);
        System.out.println("Encrypted: " + encryptedString);

        String decryptedString = decrypt(encryptedString);
        System.out.println("Decrypted: " + decryptedString);
    }
}
```

### Explanation

1. **Encryption and Decryption**:
   - The `encrypt` method takes a plaintext string, encrypts it using AES-256 with CBC mode and PKCS5 padding, and returns the Base64-encoded encrypted string.
   - The `decrypt` method takes the Base64-encoded encrypted string, decrypts it using the same key and IV, and returns the original plaintext.

2. **Key and IV**:
   - The `SECRET_KEY` and `INIT_VECTOR` are used for both encryption and decryption. Ensure that these values are securely stored and managed (e.g., using environment variables or a secure vault).

3. **Compatibility**:
   - The same key and IV can be used in both MySQL and SQL Server to ensure compatibility. You can use the encrypted data generated by this Java code in both databases.

### Access Control

Ensure that only authorized users and systems have access to the encryption keys and IV. Use role-based access control (RBAC) and restrict file permissions to sensitive configuration files.

This solution provides a secure and compatible way to handle AES-256 encryption and decryption across MySQL and SQL Server, while also addressing the broader issue of hard-coded credentials.