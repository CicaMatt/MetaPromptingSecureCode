**Objective**:
The goal is to generate a secure code snippet that effectively addresses the given problem statement, utilizing all provided mitigation strategies to prevent security vulnerabilities.

**Problem Statement**:
"I am using Java 6 and am trying to create an HttpsURLConnection against a remote server, using a client certificate.
The server is using an selfsigned root certificate, and requires that a password-protected client certificate is presented. I've added the server root certificate and the client certificate to a default java keystore which I found in /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/security/cacerts (OSX 10.5). The name of the keystore file seems to suggest that the client certificate is not supposed to go in there?

Anyway, adding the root certificate to this store solved the infamous javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed' problem.

However, I'm now stuck on how to use the client certificate. I've tried two approaches and neither gets me anywhere.
First, and preferred, try:

SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
URL url = new URL("https://somehost.dk:3049");
HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();
conn.setSSLSocketFactory(sslsocketfactory);
InputStream inputstream = conn.getInputStream();
// The last line fails, and gives:
// javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure
I've tried skipping the HttpsURLConnection class (not ideal since I want to talk HTTP with the server), and do this instead:

SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket("somehost.dk", 3049);
InputStream inputstream = sslsocket.getInputStream();
// do anything with the inputstream results in:
// java.net.SocketTimeoutException: Read timed out
I am not even sure that the client certificate is the problem here."

**Mitigation Strategies**:
1. **Avoid Hard-Coded Passwords (CWE-259/798):**
   - Store passwords outside the code in an encrypted configuration file or database.
   - Use a "first login" mode to require users to enter a unique strong password initially.
   - Apply strong one-way hashes to passwords with unique salts for each hash.
   - Limit entity access for features that require authentication.

2. **Ensure Proper Certificate Validation (CWE-295):**
   - Implement thorough certificate management, ensuring certificates are encrypted with the intended owner's public key.
   - Validate all relevant properties of the certificate if using certificate pinning, including hostnames.

3. **Use Strong Cryptographic Algorithms (CWE-327):**
   - Utilize strong, up-to-date cryptographic algorithms (e.g., those with FIPS 140-2 certification).
   - Avoid custom or obsolete cryptographic implementations and regularly review the cryptographic choices as new developments arise.
   - Ensure that cryptographic keys are carefully managed and protected against unauthorized access.
   
4. **Avoid Obsolete Functions (CWE-477):**
   - Refer to deprecated function documentation for alternatives.
   - Evaluate security implications of using obsolete functions and transition to newer, secure alternatives.

5. **Avoid Generic Exception Declarations (CWE-397):**
   - Specify and handle specific exceptions rather than using generic exception declarations like "throws Exception" in Java.

**Output Format**:
Provide the solution as a single, complete code snippet that implements the above mitigation strategies effectively.

**Solution Language**:
Java